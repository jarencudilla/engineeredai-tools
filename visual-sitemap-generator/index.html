<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Visual Sitemap Generator v1.0</title>

<style>
body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #0f172a;
    color: #e5e7eb;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    text-align: center;
    margin-bottom: 10px;
}

.subtitle {
    text-align: center;
    color: #94a3b8;
    margin-bottom: 30px;
}

input, button {
    padding: 12px;
    font-size: 1rem;
}

input {
    width: 60%;
    max-width: 500px;
}

button {
    cursor: pointer;
    background: #6366f1;
    color: white;
    border: none;
    margin-left: 10px;
}

#canvasContainer {
    margin-top: 30px;
    background: #020617;
    border: 1px solid #1e293b;
    border-radius: 8px;
    overflow: hidden;
}

svg {
    width: 100%;
    height: 800px;
}

.node rect {
    rx: 8;
}

.link {
    stroke: #475569;
    stroke-width: 2;
}
</style>
</head>

<body>
<div class="container">
    <h1>Visual Sitemap Generator</h1>
    <div class="subtitle">Semantic sitemap visualization (v1.0)</div>

    <div style="text-align:center;">
        <input id="urlInput" placeholder="https://example.com or sitemap.xml" />
        <button id="generateBtn">Generate</button>
    </div>

    <div id="canvasContainer">
        <svg id="canvas"></svg>
    </div>
</div>

<script>
class SitemapVisualizer {

    constructor() {
        this.svg = document.getElementById("canvas");
        this.nodeWidth = 220;
        this.nodeHeight = 70;
        this.vGap = 120;
        this.hGap = 60;
    }

    async generate() {
        const input = document.getElementById("urlInput").value.trim();
        if (!input) return;

        let url = input;
        if (!url.startsWith("http")) url = "https://" + url;

        const urls = await this.fetchSitemap(url);
        const tree = this.buildTree(urls);
        this.render(tree);
    }

    async fetchSitemap(url) {
        const origin = new URL(url).origin;
        const candidates = [
            url.includes(".xml") ? url : null,
            origin + "/sitemap_index.xml",
            origin + "/sitemap.xml"
        ].filter(Boolean);

        for (const candidate of candidates) {
            try {
                return await this.loadSitemap(candidate);
            } catch {}
        }
        throw new Error("No sitemap found");
    }

    async loadSitemap(url) {
        const proxy = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
        const res = await fetch(proxy);
        const text = await res.text();

        const xml = new DOMParser().parseFromString(text, "text/xml");
        const index = xml.querySelectorAll("sitemapindex > sitemap > loc");
        if (index.length) {
            let all = [];
            for (const loc of index) {
                const child = await this.loadSitemap(loc.textContent.trim());
                all = all.concat(child);
            }
            return all;
        }

        return [...xml.querySelectorAll("url > loc")].map(n => n.textContent.trim());
    }

    classify(urls) {
        const out = { pages: [], categories: {}, posts: [] };

        urls.forEach(u => {
            const path = new URL(u).pathname.replace(/\/$/, "");

            if (path === "") return;

            if (path.startsWith("/tag/")) return;

            if (path.startsWith("/category/")) {
                const slug = path.split("/")[2];
                out.categories[slug] = { slug, url: u, posts: [] };
                return;
            }

            if (path.split("/").length === 2) {
                out.posts.push({ url: u, path });
                return;
            }

            out.pages.push({ url: u, path });
        });

        return out;
    }

    buildTree(urls) {
        const classified = this.classify(urls);
        const root = {
            name: new URL(urls[0]).hostname,
            type: "root",
            children: []
        };

        if (classified.pages.length) {
            root.children.push({
                name: "Pages",
                type: "section",
                children: classified.pages.map(p => ({
                    name: p.path.split("/").pop().replace(/-/g, " "),
                    type: "page",
                    url: p.url,
                    children: []
                }))
            });
        }

        const cats = {
            name: "Categories",
            type: "section",
            children: []
        };

        Object.values(classified.categories).forEach(c => {
            cats.children.push({
                name: c.slug.replace(/-/g, " "),
                type: "section",
                url: c.url,
                children: []
            });
        });

        if (cats.children.length) root.children.push(cats);
        return root;
    }

    render(tree) {
        this.svg.innerHTML = "";
        let x = 100;
        this.drawNode(tree, x, 50);
    }

    drawNode(node, x, y) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.setAttribute("transform", `translate(${x},${y})`);

        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", -this.nodeWidth / 2);
        rect.setAttribute("y", -this.nodeHeight / 2);
        rect.setAttribute("width", this.nodeWidth);
        rect.setAttribute("height", this.nodeHeight);
        rect.setAttribute("fill", this.color(node.type));

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dy", "5");
        text.textContent = node.name;

        g.appendChild(rect);
        g.appendChild(text);
        this.svg.appendChild(g);

        if (!node.children) return;

        let startX = x - ((node.children.length - 1) * (this.nodeWidth + this.hGap)) / 2;
        node.children.forEach(child => {
            const cx = startX;
            const cy = y + this.vGap;
            this.drawLink(x, y + this.nodeHeight / 2, cx, cy - this.nodeHeight / 2);
            this.drawNode(child, cx, cy);
            startX += this.nodeWidth + this.hGap;
        });
    }

    drawLink(x1, y1, x2, y2) {
        const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
        l.setAttribute("x1", x1);
        l.setAttribute("y1", y1);
        l.setAttribute("x2", x2);
        l.setAttribute("y2", y2);
        l.setAttribute("class", "link");
        this.svg.appendChild(l);
    }

    color(type) {
        return {
            root: "#2563eb",
            section: "#9333ea",
            page: "#10b981"
        }[type] || "#64748b";
    }
}

window.addEventListener("DOMContentLoaded", () => {
    const app = new SitemapVisualizer();
    document.getElementById("generateBtn")
        .addEventListener("click", () => app.generate());
});
</script>
</body>
</html>
