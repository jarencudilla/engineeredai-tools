<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Visual Sitemap Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;
  background: linear-gradient(135deg, #0b1020, #141a33);
  color: #e5e7eb;
  min-height: 100vh;
}

header {
  padding: 30px;
  text-align: center;
}

h1 {
  font-size: 2.2rem;
  margin-bottom: 10px;
}

.subtitle {
  color: #9ca3af;
  margin-bottom: 20px;
}

input {
  width: 460px;
  max-width: 90%;
  padding: 12px;
  font-size: 16px;
  border-radius: 6px;
  border: none;
}

button {
  padding: 12px 20px;
  margin-left: 8px;
  border-radius: 6px;
  border: none;
  background: #6366f1;
  color: #fff;
  font-weight: 600;
  cursor: pointer;
}

button:hover { background: #4f46e5; }

#canvasWrap {
  height: 75vh;
  margin: 20px;
  border-radius: 12px;
  background: rgba(0,0,0,0.25);
  overflow: hidden;
  position: relative;
}

svg {
  width: 100%;
  height: 100%;
  cursor: grab;
}

.node rect {
  rx: 8;
}

.link {
  stroke: rgba(255,255,255,0.35);
  stroke-width: 2;
}

.patch-notes {
  margin: 30px;
  padding: 20px;
  background: rgba(0,0,0,0.35);
  border-radius: 10px;
  font-size: 14px;
}
</style>
</head>

<body>

<header>
  <h1>Visual Sitemap Generator</h1>
  <div class="subtitle">Semantic sitemap visualization (v1.1)</div>
  <input id="urlInput" value="https://engineeredai.net/sitemap_index.xml">
  <button id="generateBtn">Generate</button>
</header>

<div id="canvasWrap">
  <svg id="svg">
    <g id="viewport"></g>
  </svg>
</div>

<div class="patch-notes">
  <h3>Patch Notes</h3>
  <ul>
    <li><b>v1.1</b> â€“ Posts now render under categories</li>
    <li>Fixed pan & zoom by transforming SVG viewport group</li>
    <li>Bypassed proxy for same-origin sitemaps</li>
    <li>Disabled Cloudflare Rocket Loader interference</li>
    <li>Stabilized production deployment (static / cPanel)</li>
  </ul>
</div>

<script data-cfasync="false">
class SitemapVisualizer {
  constructor() {
    this.svg = document.getElementById("svg");
    this.viewport = document.getElementById("viewport");

    this.scale = 1;
    this.tx = 0;
    this.ty = 0;
    this.dragging = false;
    this.startX = 0;
    this.startY = 0;

    this.nodeW = 190;
    this.nodeH = 56;
    this.hGap = 90;
    this.vGap = 90;

    this.bind();
  }

  bind() {
    document.getElementById("generateBtn").onclick = () => this.generate();

    this.svg.addEventListener("mousedown", e => {
      this.dragging = true;
      this.startX = e.clientX - this.tx;
      this.startY = e.clientY - this.ty;
      this.svg.style.cursor = "grabbing";
    });

    window.addEventListener("mouseup", () => {
      this.dragging = false;
      this.svg.style.cursor = "grab";
    });

    this.svg.addEventListener("mousemove", e => {
      if (!this.dragging) return;
      this.tx = e.clientX - this.startX;
      this.ty = e.clientY - this.startY;
      this.applyTransform();
    });

    this.svg.addEventListener("wheel", e => {
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      this.scale = Math.min(3, Math.max(0.25, this.scale * factor));
      this.applyTransform();
    }, { passive: false });
  }

  applyTransform() {
    this.viewport.setAttribute(
      "transform",
      `translate(${this.tx},${this.ty}) scale(${this.scale})`
    );
  }

  async generate() {
    this.viewport.innerHTML = "";
    this.scale = 1;
    this.tx = this.ty = 0;
    this.applyTransform();

    const url = document.getElementById("urlInput").value.trim();
    if (!url) return;

    const entries = await this.loadSitemap(url);
    const tree = this.buildTree(entries);
    this.render(tree);
  }

  async loadSitemap(url) {
    const target = new URL(url);
    const sameOrigin = target.origin === location.origin;

    const fetchUrl = sameOrigin
      ? url
      : `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

    const res = await fetch(fetchUrl);
    if (!res.ok) throw new Error("Failed to fetch sitemap");

    const xml = new DOMParser().parseFromString(await res.text(), "text/xml");
    if (xml.querySelector("parsererror")) throw new Error("Invalid XML");

    const index = xml.querySelectorAll("sitemapindex > sitemap > loc");
    if (index.length) {
      let all = [];
      for (const n of index) {
        all = all.concat(await this.loadSitemap(n.textContent.trim()));
      }
      return all;
    }

    return [...xml.querySelectorAll("url > loc")].map(n => ({
      url: n.textContent.trim(),
      source: url
    }));
  }

  buildTree(entries) {
    const root = {
      name: new URL(entries[0].url).hostname,
      type: "root",
      children: []
    };

    const categories = {};

    entries.forEach(({ url, source }) => {
      const path = new URL(url).pathname.replace(/\/$/, "");

      if (path.startsWith("/tag/")) return;

      if (path.startsWith("/category/")) {
        const slug = path.split("/")[2];
        categories[slug] = {
          name: slug.replace(/-/g, " "),
          type: "section",
          children: []
        };
        return;
      }

      if (source.includes("post")) {
        const slug = path.split("/").pop();
        Object.values(categories).forEach(cat => {
          if (url.includes(cat.name.replace(/ /g, "-"))) {
            cat.children.push({
              name: slug.replace(/-/g, " "),
              type: "page",
              children: []
            });
          }
        });
      }
    });

    root.children.push({
      name: "Categories",
      type: "section",
      children: Object.values(categories)
    });

    return root;
  }

  render(tree) {
    let x = 0;
    this.drawNode(tree, x, 0);
  }

  drawNode(node, x, y) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttribute("transform", `translate(${x},${y})`);
    g.setAttribute("class", "node");

    const colors = {
      root: "#3b82f6",
      section: "#a855f7",
      page: "#10b981"
    };

    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("width", this.nodeW);
    rect.setAttribute("height", this.nodeH);
    rect.setAttribute("fill", colors[node.type]);

    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", this.nodeW / 2);
    text.setAttribute("y", 34);
    text.setAttribute("text-anchor", "middle");
    text.textContent = node.name;

    g.append(rect, text);
    this.viewport.appendChild(g);

    if (!node.children) return;

    node.children.forEach((child, i) => {
      const cx = x + i * (this.nodeW + this.hGap);
      const cy = y + this.vGap;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", x + this.nodeW / 2);
      line.setAttribute("y1", y + this.nodeH);
      line.setAttribute("x2", cx + this.nodeW / 2);
      line.setAttribute("y2", cy);
      line.setAttribute("class", "link");
      this.viewport.appendChild(line);

      this.drawNode(child, cx, cy);
    });
  }
}

new SitemapVisualizer();
</script>

</body>
</html>
